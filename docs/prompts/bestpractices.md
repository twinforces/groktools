bestpractices (Version 1.0)
This document outlines best practices for generating code within the groktools suite, ensuring consistency, maintainability, and clarity. These rules should be followed when creating or updating scripts, such as example_script.py, another_script.py, or any other scripts maintained with groktools.
Coding Rules
Follow the following rules when generating code:

DRY: Don't Repeat Yourself: Instead of repeating code, consider refactoring to a procedure or function. This reduces redundancy and makes future changes easier to manage.
Name Well or Comment: If the name of a procedure or class doesn’t describe what it does and why, add a docstring explaining its purpose and functionality. Clear naming or documentation ensures code is self-explanatory.
Declare Constants: Code evolves over time—make it easy to adapt. Declare constants for values that might change, following the DRY rule, to centralize modifications.
Precompile Regexes: Since regexes are constants, always use re.compile to prebuild them. This improves performance by avoiding repeated compilation during runtime.
Use Classes Judiciously: Generate a class when it encapsulates related data and behavior, improves code reuse, or simplifies maintenance. For example, use a class to represent a complex entity (e.g., a Charity with methods for managing grants in a Sankey diagram). Avoid classes for simple data structures better suited to dictionaries or tuples, or for one-off tasks that don’t need state management.
Leverage MVVM for Separation of Concerns: When a script involves data processing and presentation (e.g., generating stats or visualizations), consider using the Model-View-ViewModel (MVVM) pattern. The Model holds data and logic (e.g., parsing IRS 527 data), the View handles presentation (e.g., outputting to a file or UI), and the ViewModel acts as a mediator, transforming Model data for the View and handling user interactions. MVVM keeps scripts modular and testable—crucial for long-term maintenance. For example, in a script generating a Sankey diagram, the Model could manage raw data, the ViewModel could compute node positions, and the View could render the output. Apply MVVM when separation of concerns reduces complexity, but avoid overengineering simple scripts with minimal data transformations.
Write Automated Tests for Core Functionality: Especially with classes and MVVM, Ensure core functionality is covered by automated tests to catch regressions and verify behavior. Use Python’s unittest or pytest for simplicity. For example, in a script like process_527_stats.py, write tests for parsing functions (e.g., process_data) to verify they handle pipe-separated data correctly. Focus tests on critical paths (e.g., data validation, output formatting) rather than trivial operations. Keep tests DRY by using fixtures or helper functions for setup (e.g., mock input data). Avoid over-testing—simple scripts may only need a few key assertions.
Handle Errors Proactively and Log Clearly: Anticipate potential failures (e.g., invalid data, file I/O issues) and handle them gracefully with try-except blocks. Raise specific exceptions for unrecoverable errors, providing clear error messages (e.g., raise ValueError("Expected pipe-separated data, got: " + data)). Log errors with context (e.g., line number, input data snippet) to a dedicated file or stderr, ensuring they’re easy to trace at 3am. For example, in a script parsing IRS data, catch and log malformed records (e.g., logging.error(f"Invalid record at line {line_num}: {line}")) while allowing the script to continue processing valid data. Avoid overly broad exception handling (e.g., except Exception)—be specific to maintain clarity.
Trust Data Over Spec: Reality is always greater than theory—when the data and the specification conflict, prioritize the data. Specifications are often idealized, but data reflects actual usage. For example, if a spec defines a field as a ZIP code but the data includes city names, adapt the script to handle the reality (e.g., by adding validation and logging for unexpected values). Validate assumptions against real data samples early to avoid surprises in production.
Include Detailed Debug Logs with Context: When adding logs for debugging, ensure they contain enough information to solve the bug, such as variable values, line numbers, and input data snippets. Use a separate log file (e.g., debug.log) for detailed output to avoid overwhelming the user with noise in the main output or console. For example, in a script parsing data, log invalid records with context (e.g., logging.debug(f"Line {line_num}: Invalid record: {line}, expected {expected_fields} fields, got {len(fields)}")) to a debug file, while keeping user-facing logs concise (e.g., logging.error(f"Line {line_num}: Invalid record")). You only need to log a few examples of an error for debugging in general, just count after that. 
Naming: CamelCase for classes, instanceVariable for instance variables, UPPERCASE for Constants, underscores for non classes.
Stupidity: Double check the code, especially for interpreted languages where errors may not be found until runtime. Are variables declared before usage? Any obvious syntax errors? Look line by line if you have to before pronouncing the code complete.
tqdm: use tqdm to display progress for long running operations. In major/minor situations, use tqdm bar for the minor, 1/25 log for the major. 
Use the Cores luke: Modern computers have many cores, for large operations use thread pools. See aiofiles below.
aiofiles: Use aiofiles when building async applications with frequent or concurrent file I/O to keep the event loop non-blocking. Stick to synchronous I/O for simple, synchronous, or infrequent file operations to avoid unnecessary complexity.



Usage
When generating or modifying code, refer to these best practices to ensure high-quality output. For example, when updating process_527_stats.py, apply these rules to maintain clean, efficient, and understandable code.
These practices are referenced in the groktools Meta prompt (https://github.com/twinforces/groktools/docs/prompts/groktools_meta_prompt.md) and should be followed in conjunction with tool-specific prompts.
